#!/usr/bin/env python3
"""
Fix Reference Number Duplication Issue

This script addresses the duplicate reference number fields in reports:
1. Root-level 'reference_number' (generated by backend)
2. 'report_data.report_reference_number' (sent by frontend)

Solution:
- Backend correctly generates reference_number at root level
- Frontend should not send report_reference_number in form data
- Update existing reports to remove duplicate field
- Ensure single source of truth for reference numbers
"""

import asyncio
import os
import sys
from datetime import datetime
from typing import Dict, Any, Optional
import json

# Add backend directory to path
sys.path.append('/Users/sandeepjangra/Downloads/development/ValuationAppV1/backend')

from database.multi_db_manager import MultiDatabaseManager

class ReferenceDuplicationFixer:
    def __init__(self):
        self.db_manager = MultiDatabaseManager()
    
    async def connect(self):
        """Connect to MongoDB"""
        try:
            await self.db_manager.connect()
            print("‚úÖ Connected to MongoDB Atlas")
        except Exception as e:
            print(f"‚ùå Failed to connect to MongoDB: {e}")
            raise
    
    async def disconnect(self):
        """Disconnect from MongoDB"""
        try:
            await self.db_manager.disconnect()
            print("‚úÖ Disconnected from MongoDB")
        except Exception as e:
            print(f"‚ö†Ô∏è Error disconnecting: {e}")
    
    async def analyze_reference_duplication(self, org_short_name: str = "sk-tindwal"):
        """Analyze reports for reference number duplication"""
        print(f"\nüîç Analyzing reference number duplication for organization: {org_short_name}")
        
        try:
            org_db = self.db_manager.get_org_database(org_short_name)
            
            # Get all reports
            reports = await org_db.reports.find({}).to_list(None)
            
            print(f"\nüìä Found {len(reports)} reports to analyze")
            
            duplicates_found = 0
            mismatches = 0
            clean_reports = 0
            
            for report in reports:
                report_id = report.get('report_id', 'Unknown')
                root_ref = report.get('reference_number')
                nested_ref = report.get('report_data', {}).get('report_reference_number')
                
                has_both = root_ref and nested_ref
                has_mismatch = has_both and root_ref != nested_ref
                
                if has_both:
                    duplicates_found += 1
                    status = "MISMATCH" if has_mismatch else "DUPLICATE"
                    print(f"  {status}: {report_id}")
                    print(f"    Root: {root_ref}")
                    print(f"    Nested: {nested_ref}")
                    
                    if has_mismatch:
                        mismatches += 1
                elif root_ref and not nested_ref:
                    clean_reports += 1
                elif nested_ref and not root_ref:
                    print(f"  MISSING ROOT: {report_id} - only has nested reference: {nested_ref}")
            
            print(f"\nüìà Analysis Results:")
            print(f"  Total reports: {len(reports)}")
            print(f"  Reports with duplicates: {duplicates_found}")
            print(f"  Reports with mismatches: {mismatches}")
            print(f"  Clean reports (root only): {clean_reports}")
            print(f"  Reports needing cleanup: {duplicates_found}")
            
            return {
                'total': len(reports),
                'duplicates': duplicates_found,
                'mismatches': mismatches,
                'clean': clean_reports
            }
            
        except Exception as e:
            print(f"‚ùå Error analyzing reports: {e}")
            raise
    
    async def fix_reference_duplication(self, org_short_name: str = "sk-tindwal", dry_run: bool = True):
        """Fix reference number duplication by removing nested field"""
        print(f"\nüîß {'[DRY RUN] ' if dry_run else ''}Fixing reference number duplication")
        
        try:
            org_db = self.db_manager.get_org_database(org_short_name)
            
            # Find reports with duplicate reference fields
            reports = await org_db.reports.find({
                "reference_number": {"$exists": True},
                "report_data.report_reference_number": {"$exists": True}
            }).to_list(None)
            
            print(f"üìã Found {len(reports)} reports with duplicate reference fields")
            
            if len(reports) == 0:
                print("‚úÖ No duplicate reference fields found!")
                return
            
            fixed_count = 0
            
            for report in reports:
                report_id = report.get('report_id')
                root_ref = report.get('reference_number')
                nested_ref = report.get('report_data', {}).get('report_reference_number')
                
                print(f"\n  Processing: {report_id}")
                print(f"    Root reference: {root_ref}")
                print(f"    Nested reference: {nested_ref}")
                
                if root_ref != nested_ref:
                    print(f"    ‚ö†Ô∏è MISMATCH detected! Keeping root reference: {root_ref}")
                
                if not dry_run:
                    # Remove the nested reference field
                    update_result = await org_db.reports.update_one(
                        {"report_id": report_id},
                        {"$unset": {"report_data.report_reference_number": ""}}
                    )
                    
                    if update_result.modified_count > 0:
                        fixed_count += 1
                        print(f"    ‚úÖ Removed duplicate nested reference")
                    else:
                        print(f"    ‚ùå Failed to update report")
                else:
                    fixed_count += 1
                    print(f"    üîç Would remove nested reference field")
            
            print(f"\nüìà Summary:")
            print(f"  Reports processed: {len(reports)}")
            print(f"  Reports {'that would be ' if dry_run else ''}fixed: {fixed_count}")
            
            if dry_run:
                print(f"\n‚ö†Ô∏è This was a DRY RUN. No changes were made.")
                print(f"   Run with --fix to apply changes.")
            else:
                print(f"\n‚úÖ Reference duplication cleanup completed!")
            
        except Exception as e:
            print(f"‚ùå Error fixing references: {e}")
            raise
    
    async def validate_reference_uniqueness(self, org_short_name: str = "sk-tindwal"):
        """Validate that all reference numbers are unique"""
        print(f"\nüîç Validating reference number uniqueness for: {org_short_name}")
        
        try:
            org_db = self.db_manager.get_org_database(org_short_name)
            
            # Aggregate to find duplicate reference numbers
            pipeline = [
                {
                    "$group": {
                        "_id": "$reference_number",
                        "count": {"$sum": 1},
                        "reports": {"$push": {"report_id": "$report_id", "created_at": "$created_at"}}
                    }
                },
                {
                    "$match": {
                        "count": {"$gt": 1}
                    }
                }
            ]
            
            duplicates = await org_db.reports.aggregate(pipeline).to_list(None)
            
            if len(duplicates) == 0:
                print("‚úÖ All reference numbers are unique!")
            else:
                print(f"‚ö†Ô∏è Found {len(duplicates)} duplicate reference numbers:")
                for dup in duplicates:
                    ref_num = dup['_id']
                    count = dup['count']
                    reports = dup['reports']
                    
                    print(f"\n  Reference: {ref_num} (appears {count} times)")
                    for report in reports:
                        print(f"    - Report ID: {report['report_id']}, Created: {report['created_at']}")
            
            return len(duplicates) == 0
            
        except Exception as e:
            print(f"‚ùå Error validating uniqueness: {e}")
            raise

async def main():
    """Main function with command line interface"""
    import argparse
    
    parser = argparse.ArgumentParser(description='Fix Reference Number Duplication')
    parser.add_argument('--org', default='sk-tindwal', help='Organization short name')
    parser.add_argument('--analyze', action='store_true', help='Analyze duplicate references')
    parser.add_argument('--fix', action='store_true', help='Fix duplicate references')
    parser.add_argument('--validate', action='store_true', help='Validate reference uniqueness')
    parser.add_argument('--all', action='store_true', help='Run all operations')
    
    args = parser.parse_args()
    
    fixer = ReferenceDuplicationFixer()
    
    try:
        await fixer.connect()
        
        if args.all or args.analyze:
            await fixer.analyze_reference_duplication(args.org)
        
        if args.all or args.fix:
            # Ask for confirmation before fixing
            if not args.all:
                confirm = input("\n‚ö†Ô∏è This will modify your database. Continue? (y/N): ")
                if confirm.lower() != 'y':
                    print("‚ùå Operation cancelled")
                    return
            
            await fixer.fix_reference_duplication(args.org, dry_run=False)
        
        if args.all or args.validate:
            await fixer.validate_reference_uniqueness(args.org)
        
        if not any([args.analyze, args.fix, args.validate, args.all]):
            print("üîç Running analysis only (use --help for options)")
            await fixer.analyze_reference_duplication(args.org)
    
    finally:
        await fixer.disconnect()

if __name__ == "__main__":
    asyncio.run(main())